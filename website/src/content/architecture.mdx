---
title: Architecture
description: How Argus is structured internally — bounded contexts, data flow, and module layout.
order: 3
---

## High-Level Design

Argus follows a clean architecture with strict layer dependency rules:

```
interfaces → application → domain ← infrastructure
                             ↓
                           shared
```

- **shared** — Foundation types, exceptions, constants. Zero internal imports.
- **domain** — Pure domain logic with protocol definitions. Imports only from shared.
- **application** — Use-case orchestrators. Imports from domain and shared.
- **infrastructure** — Concrete implementations of domain protocols. Imports from domain and shared.
- **interfaces** — Entry point and composition root. Wires everything together.

## Module Structure

```
src/argus/
├── shared/           # Types, exceptions, constants
├── domain/
│   ├── context/      # Codebase map: entities, indexing, parsing protocols
│   ├── retrieval/    # Context retrieval: strategies, ranker, orchestrator
│   ├── review/       # Review: entities, noise filter, publisher protocol
│   └── llm/          # LLM config: ModelConfig, TokenBudget
├── application/      # Use-case orchestrators
├── infrastructure/
│   ├── parsing/      # Tree-sitter AST parser + code chunker
│   ├── retrieval/    # Structural, lexical (BM25), agentic strategies
│   ├── llm_providers/# pydantic-ai Agent factory
│   ├── storage/      # Codebase map JSON persistence
│   └── github/       # GitHub API client + review publisher
└── interfaces/       # Config, composition root, action handler
```

## Data Flow: PR Review

1. **PR event** triggers the GitHub Action
2. **Interfaces** layer reads config from environment, builds the dependency graph
3. **Application** orchestrator pulls codebase artifacts from the `argus-data` branch
4. For each changed file in the PR diff:
   - **Retrieval** strategies find relevant context (structural neighbors, BM25 matches)
   - **Ranker** scores and selects the top context chunks
5. The diff + context bundle goes to the **LLM provider** for review
6. **Noise filter** drops low-confidence or redundant comments
7. **Publisher** posts surviving comments as inline PR review annotations

## Artifact Storage

Argus stores its codebase map and pattern memory on an orphan branch (`argus-data`) in your repository using the Git Data API. This avoids polluting your main branch history and requires no external database or storage service.

The artifacts include:
- **Codebase map** — Serialized index of all parsed files, functions, classes, and their relationships
- **Pattern memory** — Learned conventions and anti-patterns from previous analysis cycles

## Indexing

### Bootstrap Mode
Parses every file in the repository, builds the full codebase map, runs pattern analysis via LLM, and pushes all artifacts to the data branch.

### Incremental Index Mode
Uses `compare_commits` to detect changed files since the last indexed commit. Only re-parses those files and updates the relevant map entries. No LLM calls — purely structural updates.

## Retrieval Strategies

- **Structural** — Follows import/export relationships and call graphs from the codebase map
- **Lexical (BM25)** — Token-based search across the indexed codebase for relevant terms
- **Agentic** (optional) — LLM-guided exploration when structural and lexical retrieval isn't sufficient
